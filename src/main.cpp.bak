#include <iostream>
#include <fstream> // ifstream
#include <sstream> // sstream
#include <string> // string
#include <vector> // vector
#include <algorithm> // remove_if
#include <cassert> // assert
#include <cstdlib> // atof
#include <cstddef> // size_t
#include <memory> // shared_ptr, make_shared
#include <chrono> // chrono

#include <gmpxx.h>

typedef mpq_class rational_t;
//typedef double rational_t;

typedef long long int int_t;

const rational_t rational_minus_one  = -1;
const rational_t rational_zero = 0;
const rational_t rational_one = 1;
const rational_t rational_two = 2;
const int_t integer_zero = 0;
const int_t integer_one = 1;
const int_t integer_two = 2;

// TODO - cache

//std::vector<std::pair<std::string,rational_t>> symbol_table = {
//    {"dimS",1},
//    {"mT",2},
//    {"mH",3},
//    {"TR",4},
//    {"i_",5},
//    {"NC",6}
//};

std::vector<std::pair<const std::string,const rational_t>> symbol_table =
{
    {"a1",252097800623_mpq/7732459473917_mpq},
    {"a2",790645490059_mpq/13730453361421_mpq},
    {"a3",1344326694119_mpq/19819454169467_mpq},
    {"a4",1906555030411_mpq/25971199844383_mpq},
    {"a5",2474799787573_mpq/32170948946749_mpq},
    {"a6",3047695447799_mpq/38409597323033_mpq}
};

rational_t term_result = rational_one;
rational_t number_result = rational_one;
rational_t powbuffer_result = rational_one;

enum Operation { add, subtract, multiply, divide, inverse};

struct slice_t
{
    std::shared_ptr<std::string> expression; // TODO - const
    std::size_t pos;
    std::size_t len;
    
    const char& operator[](const std::size_t index) const { return (*expression)[pos+index]; }
    
    friend inline bool operator==(const slice_t& lhs, const std::string& rhs)
    {
        if (lhs.len != rhs.length())
            return false;
        for (std::size_t i=0; i<lhs.len; ++i)
        {
            if( lhs[i] != rhs[i] )
                return false;
        }
        return true;
    }
    friend inline bool operator!=(const slice_t& lhs, const std::string& rhs){ return !(lhs == rhs); }
    friend std::ostream& operator<<(std::ostream& os, const slice_t& slice) { os << slice.expression->substr(slice.pos,slice.len); return os; }
};

void exparse_apply(rational_t& result, const rational_t& symbol, const Operation op)
{
    if(op == subtract)
    {
        result -= symbol;
        return;
    }
    else if(op == divide)
    {
        result /= symbol;
        return;
    }
    else if (op == add)
    {
        result *= symbol;
        return;
    }
    else if (op == multiply)
    {
        result *= symbol;
        return;
    }
    else if (op == inverse)
    {
        result = symbol/result;
        return;
    }
}

void exparse_pow(rational_t& base, const int_t& exponent, rational_t& result, Operation op)
{
    if (exponent < integer_zero)
    {
        exparse_apply(result, rational_one, inverse); // 1/result
        exparse_pow(base, -exponent, result, op);
        exparse_apply(result, rational_one, inverse); // 1/result
        return;
    }
    else if (exponent == integer_zero)
    {
        return; // nothing to do
    }
    else if (exponent == integer_one)
    {
        exparse_apply(result, base, op);
        return;
    }
    else if (exponent == integer_two)
    {
        exparse_apply(result, base*base, op);
        return;
    }

    powbuffer_result = rational_one;
    int_t tmp_exponent = exponent;
    while(tmp_exponent > 0)
    {
        if(tmp_exponent & 1) // exponent is odd
            powbuffer_result *= base;
        base *= base;
        tmp_exponent = tmp_exponent >> 1;
    }
    exparse_apply(result, powbuffer_result, op);
}

void to_number(slice_t& symbol, rational_t& number)
{
    for (const std::pair<std::string,rational_t>& possible_symbol : symbol_table)
    {
        if( symbol == possible_symbol.first )
        {
            number = possible_symbol.second;
            return;
        }
    }
    
//    rational_t number_result = rational_one;
    if ( symbol.pos+symbol.len != symbol.expression->length() )
    {
        const char store =(*symbol.expression)[symbol.pos+symbol.len];
        (*symbol.expression)[symbol.pos+symbol.len] = '\0';
        number = rational_t(symbol.expression->c_str()+symbol.pos);
//        number_result = std::atof(symbol.expression->c_str()+symbol.pos);
        (*symbol.expression)[symbol.pos+symbol.len] = store;
    }
    else
    {
        number = rational_t(symbol.expression->c_str()+symbol.pos);
//        number_result = std::atof(symbol.expression->c_str()+symbol.pos);
    }
    return;
}

int_t to_int(slice_t& symbol)
{
    int_t result;
    if ( symbol.pos+symbol.len != symbol.expression->length() )
    {
        const char store =(*symbol.expression)[symbol.pos+symbol.len];
        (*symbol.expression)[symbol.pos+symbol.len] = '\0';
        result = std::atoll(symbol.expression->c_str()+symbol.pos);
        (*symbol.expression)[symbol.pos+symbol.len] = store;
    }
    else
    {
        result = std::atoll(symbol.expression->c_str()+symbol.pos);
    }
    return result;
}

void parse_symbol(slice_t& symbol, rational_t& result)
{
//    std::cout << "-->" << symbol << std::endl;
    
    std::size_t symbol_pos = symbol.pos;
    std::size_t symbol_len = symbol.len;
    
    // Parse operator
    Operation op = add;
    if( symbol[0] == '+')
    {
        symbol.pos++;
        symbol.len--;
        op = add;
    }
    else if( symbol[0] == '-')
    {
        symbol.pos++;
        symbol.len--;
        op = subtract;
    }
    else if( symbol[0] == '*')
    {
        symbol.pos++;
        symbol.len--;
        op = multiply;
    }
    else if( symbol[0] == '/')
    {
        symbol.pos++;
        symbol.len--;
        op = divide;
    }
    
    // Parse power
    bool power = false;
    for (std::size_t i=0; i<symbol.len; ++i)
    {
        if( symbol[i] == '^')
        {
            slice_t base_slice = {symbol.expression,symbol.pos,i};
            slice_t exponent_slice = {symbol.expression,symbol.pos+i+1,symbol.len-(i+1)};
            
//            std::cout << "base: " << base_slice << std::endl;
//            std::cout << "exponent: " << exponent_slice << std::endl;
            to_number(base_slice,number_result);
            exparse_pow(number_result, to_int(exponent_slice), result, op);

            return;
        }
    }

    // Parse non-power
    to_number(symbol,number_result);
    exparse_apply(result,number_result,op);
    return;
}

rational_t& parse_term(slice_t& term)
{
//    std::cout << "term:" << term << " (" << term.pos << "," << term.len << ")" << std::endl;
    
    std::size_t term_pos = term.pos;
    std::size_t term_len = term.len;
    
    term_result = rational_one;

    std::size_t reading_point = 0;
    for (std::size_t i=0; i<term.len; ++i)
    {
        if( term[i] == '*' || term[i] == '/')
        {
            // Parse term
            term.pos = term_pos+ reading_point;
            term.len = i-reading_point;
            parse_symbol(term, term_result);
            
            // Update reading point
            reading_point = i;
            
            // Reset term to original parameters
            term.pos = term_pos;
            term.len = term_len;
        }
        else if ( i == term.len-1 )
        {
            // Parse term
            term.pos = term_pos+ reading_point;
            term.len = i+1-reading_point;
            parse_symbol(term, term_result);
            
            // Update reading point
            reading_point = i+1;
            
            // Reset term to original parameters
            term.pos = term_pos;
            term.len = term_len;
        }
    }
    
//    std::cout << "= " << result << std::endl;
    return term_result;
}

void parse_line(slice_t& line, rational_t& result)
{
    std::cout << "line length: " << line.len << std::endl;
    
    std::size_t line_pos = line.pos;
    std::size_t line_len = line.len;
    
    std::size_t reading_point = 0;
    for (std::size_t i=0; i<line.len; ++i)
    {
        if( i != 0 && (line[i] == '+' || (line[i] == '-' && line[i-1] != '^') ))
        {
            // Parse term
            line.pos = line_pos + reading_point;
            line.len = i-reading_point;
            result += parse_term(line);
            
            // Update reading point
            reading_point = i;
            
            // Reset line to original parameters
            line.pos = line_pos;
            line.len = line_len;
        }
        else if (i == line.len-1)
        {
            // Parse term
            line.pos = line_pos + reading_point;
            line.len = i+1-reading_point;
            result += parse_term(line);
            
            // Update reading point

            reading_point = i+1;
            
            // Reset line to original parameters
            line.pos = line_pos;
            line.len = line_len;
        }
    }
    std::cout << "Result: " << result << std::endl;
}

void parse_sanity(slice_t& line)
{
    for (std::size_t i=0; i<line.expression->length(); ++i)
    {
        assert(line[i]!='(');
        assert(line[i]!=')');
        assert(line[i]!=' ');
        assert(line[i]!=';');
    }
    assert(line[line.expression->length()-1] != '+');
    assert(line[line.expression->length()-1] != '-');
    assert(line[line.expression->length()-1] != '*');
    assert(line[line.expression->length()-1] != '^');
}

rational_t parse_file(const std::string& filename)
{
    
    auto start = std::chrono::steady_clock::now();
    auto end = std::chrono::steady_clock::now();
    auto diff = end - start;
    
    start = std::chrono::steady_clock::now();
    std::ifstream infile(filename);
    end = std::chrono::steady_clock::now();
    diff = end - start;
    
    std::cout << "file opened (" <<  std::chrono::duration<double,std::milli>(diff).count() << " ms)" << std::endl;
    
    // TODO force allocation of large amount of memory
//     rational_t result = rational_t("442732151359390185581929906993038781799050602817261858887861153945583510697/442732151586791925032671035345231161654219873495818231728186436364641909799");
    rational_t result = rational_zero;
    
    slice_t line;
    
    std::string expression;
    start = std::chrono::steady_clock::now();
    while (std::getline(infile, expression))
    {
        end = std::chrono::steady_clock::now();
        diff = end - start;
        std::cout << "read line (" <<  std::chrono::duration<double,std::milli>(diff).count() << " ms)" << std::endl;
        
        line.expression = std::make_shared<std::string>(expression); // TODO - const
        line.pos = 0;
        line.len = line.expression->length();
    
        start = std::chrono::steady_clock::now();
        // parse_sanity(line);
        parse_line(line, result);
        end = std::chrono::steady_clock::now();
        diff = end - start;
        
        std::cout << "parsed line (" <<  std::chrono::duration<double,std::milli>(diff).count() << " ms)" << std::endl;
        start = std::chrono::steady_clock::now();
    }
    return result;
}

int main()
{
    rational_t result = parse_file("expr2.out.txt");
    
    return 0;
}
